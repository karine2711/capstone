package com.aua.museum.booking.service.impl;import com.aua.museum.booking.domain.Question;import com.aua.museum.booking.domain.QuestionDetails;import com.aua.museum.booking.domain.User;import com.aua.museum.booking.domain.UserState;import com.aua.museum.booking.exception.UserAccountIsAlreadyBlockedException;import com.aua.museum.booking.exception.notfound.UserNotFoundException;import com.aua.museum.booking.exception.notunique.FieldsAlreadyExistException;import com.aua.museum.booking.repository.UserRepository;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.Mock;import org.mockito.Mockito;import org.mockito.junit.jupiter.MockitoExtension;import org.springframework.security.core.session.SessionRegistryImpl;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.web.multipart.MultipartHttpServletRequest;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.List;import java.util.Optional;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.*;import static org.mockito.BDDMockito.given;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;@ExtendWith(MockitoExtension.class)class UserServiceImplTest {    private static UserServiceImpl userService;    private final String USERNAME = "johnsmith";    private final String FULL_NAME = "John Smith";    private final String EMAIL = "jjsmith@mymail.com";    final String BLOCKED_EMAIL = "_blocked_" + EMAIL;    private final String PASSWORD = "pass";    private final String PHONE = "+37411111111";    private final PasswordEncoder DEFAULT_ENCODER = new BCryptPasswordEncoder();    private final Path PATH = Paths.get("src/main/resources/static/images/bg.jpg");    private final String USER_NOT_FOUND_DEFAULT = "User not found!";    private final String USER_NOT_FOUND_INFO = "User not found: %s";    private final User DEFAULT_USER = User.builder()            .username(USERNAME)            .fullName(FULL_NAME)            .email(EMAIL)            .password(PASSWORD)            .phone(PHONE)            .build();    @Mock    MultipartHttpServletRequest request;    private UserRepository userRepository;    private SessionRegistryImpl sessionRegistry;    private QuestionDetails firstQuestionDetails = new QuestionDetails();    private QuestionDetails secondQuestionDetails = new QuestionDetails();    private ArrayList<QuestionDetails> questionDetails = new ArrayList<>() {        {            add(firstQuestionDetails);            add(secondQuestionDetails);        }    };    @BeforeEach    void setup() throws IOException {        userRepository = Mockito.mock(UserRepository.class);        sessionRegistry = Mockito.mock(SessionRegistryImpl.class);        userService = new UserServiceImpl(userRepository, sessionRegistry);        userService.setEncoder(DEFAULT_ENCODER);        DEFAULT_USER.setProfileAvatar(Files.readAllBytes(PATH));        firstQuestionDetails.setQuestion(new Question());        firstQuestionDetails.setAnswer("answer1");        firstQuestionDetails.setUser(new User());        firstQuestionDetails.setId(1L);        secondQuestionDetails.setQuestion(new Question());        secondQuestionDetails.setAnswer("answer2");        secondQuestionDetails.setUser(new User());        secondQuestionDetails.setId(1L);        DEFAULT_USER.setQuestionsDetails(questionDetails);    }    @Test    void createUserWhenValidUserIsPassed() {        List<QuestionDetails> questionDetails = new ArrayList<>();        Question question = new Question();        QuestionDetails detail = new QuestionDetails();        question.setDescriptionEN("question");        detail.setQuestion(question);        detail.setAnswer("yes");        questionDetails.add(detail);        DEFAULT_USER.setQuestionsDetails(questionDetails);        given(userRepository.existsByUsername(USERNAME))                .willReturn(false);        given(userRepository.save(any(User.class))).willAnswer(invocation -> invocation.getArgument(0));        User createdUser = userService.createUser(DEFAULT_USER);        createdUser.getQuestionsDetails().forEach(questionDetail -> assertEquals(DEFAULT_USER, questionDetail.getUser()));        assertEquals(DEFAULT_USER.getQuestionsDetails(), createdUser.getQuestionsDetails());        assertEquals(DEFAULT_USER, createdUser);    }    @Test    void shouldReturnBase64EncodeAvatar() {        String base64EncodedAvatar = userService.extractAvatarPicture(DEFAULT_USER);        assertNotNull(base64EncodedAvatar);    }    @Test    void shouldUpdateUserCorrectly() {        given(userRepository.findByUsername(anyString())).willReturn(Optional.ofNullable(DEFAULT_USER));        assert DEFAULT_USER != null;        userService.updateUser(DEFAULT_USER, request);        verify(userRepository, times(1)).save(any());    }    @Test    void verifyDeletingUser() {        userService.deleteUserByUsername(anyString());        verify(userRepository, times(1)).deleteByUsername(anyString());    }    @Test    void throwUsernameAlreadyExistsWhenSavingUserWithExistingUsername() {        given(userRepository.existsByUsername(USERNAME))                .willReturn(true);        String message = assertThrows(FieldsAlreadyExistException.class, () -> userService.createUser(DEFAULT_USER)).getMessage();    }    @Test()    void throwEmailBoundToOtherAccountWhenSavingUserWithExistingEmail() {        given(userRepository.existsByEmail(EMAIL))                .willReturn(true);        String message = assertThrows(FieldsAlreadyExistException.class, () -> userService.createUser(DEFAULT_USER)).getMessage();    }    @Test    void getUserById() {        final long ID = 1L;        DEFAULT_USER.setId(ID);        given(userRepository.findById(anyLong()))                .willReturn(Optional.of(DEFAULT_USER));        assertEquals(DEFAULT_USER, userService.getUserById(ID));        DEFAULT_USER.setId(null);    }    @Test    void throwUserNotFoundExceptionWhenPassingNonExistingId() {        final String USER_NOT_FOUND_ID = "User with id %d not found!";        final long ID = 1L;        given(userRepository.findById(anyLong()))                .willReturn(Optional.empty());        String message = assertThrows(UserNotFoundException.class, () -> userService.getUserById(ID)).getMessage();        assertTrue(message.equals(String.format(USER_NOT_FOUND_ID, ID)) || message.equals(USER_NOT_FOUND_DEFAULT));    }    @Test    void getUserByUsername() {        given(userRepository.findByUsername(anyString()))                .willReturn(Optional.of(DEFAULT_USER));        assertEquals(DEFAULT_USER, userService.getUserByUsername(USERNAME));    }    @Test    void throwUserNotFoundWhenPassingNonExistingUsername() {        given(userRepository.findByUsername(anyString()))                .willReturn(Optional.empty());        String message = assertThrows(UserNotFoundException.class,                () -> userService.getUserByUsername(USERNAME)).getMessage();    }    @Test    void getUserByEmail() {        given(userRepository.findByEmail(anyString()))                .willReturn(Optional.of(DEFAULT_USER));        assertEquals(DEFAULT_USER, userService.getUserByEmail(EMAIL));    }    @Test    void throwUserNotFoundWhenPassingNonExistingEmail() {        given(userRepository.findByEmail(anyString()))                .willReturn(Optional.empty());        String message = assertThrows(UserNotFoundException.class,                () -> userService.getUserByEmail(EMAIL)).getMessage();    }    @Test    void getAllUsers() {        List<User> list = List.of(DEFAULT_USER);        given(userRepository.findAll()).willReturn(list);        assertEquals(list, userService.getAllUsers());    }    @Test    void blockUserByEmailGivenTheUserExistsAndIsNotBlocked() {        DEFAULT_USER.setId(1L);        given(userRepository.findByEmail(anyString()))                .willReturn(Optional.of(DEFAULT_USER));        given(userRepository.save(any(User.class))).willAnswer(invocation -> invocation.getArgument(0));        String blockedEmail = 1 + BLOCKED_EMAIL;        User user = userService.blockUserByEmail(EMAIL);        assertEquals(DEFAULT_USER, user);        assertEquals(blockedEmail, user.getEmail());        assertEquals(UserState.BLOCKED, user.getState());        DEFAULT_USER.setId(null);    }    @Test    void throwUserNotFoundExceptionGivenTheUserDoesntExist() {        given(userRepository.findByEmail(anyString()))                .willReturn(Optional.empty());        assertThrows(UserNotFoundException.class, () -> userService.blockUserByEmail(EMAIL));    }    @Test    void throwUserAccountAlreadyBlockedGivenTheUserExistsAndIsBlocked() {        String blockedUsersEmail = 1 + BLOCKED_EMAIL;        User blockedUser = User.builder()                .username(USERNAME)                .phone(PHONE)                .fullName(FULL_NAME)                .password(PASSWORD)                .email(1 + BLOCKED_EMAIL)                .id(1L)                .build();        blockedUser.setState(UserState.BLOCKED);        given(userRepository.findByEmail(EMAIL))                .willReturn(Optional.empty());        given(userRepository.findByEmail(blockedUsersEmail))                .willReturn(Optional.of(blockedUser));        assertThrows(UserAccountIsAlreadyBlockedException.class, () -> userService.blockUserByEmail(blockedUsersEmail));        assertThrows(UserNotFoundException.class, () -> userService.blockUserByEmail(EMAIL));    }    @Test    void changePassword() {        DEFAULT_USER.setId(1L);        given(userRepository.findByEmail(anyString())).willReturn(Optional.of(DEFAULT_USER));        given(userRepository.save(any(User.class)))                .willAnswer(invocation -> invocation.getArgument(0));        given(userRepository.findById(anyLong())).willReturn(Optional.of(DEFAULT_USER));        User updatedUser = userService.changePassword(EMAIL, "newPass");        System.out.println(updatedUser.getPassword());        System.out.println(DEFAULT_USER.getPassword());        assertEquals(DEFAULT_USER, updatedUser);        assertEquals(updatedUser.getPassword(), userService.getUserById(updatedUser.getId()).getPassword());        DEFAULT_USER.setId(null);    }}